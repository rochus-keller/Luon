<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>No Name</title><link rel="stylesheet" href="https://thetimetube.herokuapp.com/asciidoc/asciidoc/css/adoc-readthedocs.css"><style>body{margin:5px 7px 5px 7px}</style><style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Menu_Button .MathJax_Hover_Arrow {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; -khtml-border-radius: 4px; font-family: 'Courier New',Courier; font-size: 9px; color: #F0F0F0}
.MathJax_Menu_Button .MathJax_Hover_Arrow span {display: block; background-color: #AAA; border: 1px solid; border-radius: 3px; line-height: 0; padding: 4px}
.MathJax_Hover_Arrow:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_Hover_Arrow:hover span {background-color: #CCC!important}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_About.MathJax_MousePost {outline: none}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 5px 0px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 5px; -webkit-border-radius: 5px; -moz-border-radius: 5px; -khtml-border-radius: 5px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 1px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; padding-top: .25em; color: #666666; font-size: .75em}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: .7em}
.MathJax_MenuRadioCheck.RTL {right: .7em; left: auto}
.MathJax_MenuLabel {padding: 1px 2em 3px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #DDDDDD; margin: 4px 3px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: #606872; color: white}
.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus {background-color: #E8E8E8}
.MathJax_ContextMenu:focus {outline: none}
.MathJax_ContextMenu .MathJax_MenuItem:focus {outline: none}
#MathJax_AboutClose {top: .2em; right: .2em}
.MathJax_Menu .MathJax_MenuClose {top: -10px; left: -10px}
.MathJax_MenuClose {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; font-family: 'Courier New',Courier; font-size: 24px; color: #F0F0F0}
.MathJax_MenuClose span {display: block; background-color: #AAA; border: 1.5px solid; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; line-height: 0; padding: 8px 0 6px}
.MathJax_MenuClose:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_MenuClose:hover span {background-color: #CCC!important}
.MathJax_MenuClose:hover:focus {outline: none}
</style><style type="text/css">.MathJax_Preview .MJXf-math {color: inherit!important}
</style><style type="text/css">.MJX_Assistive_MathML {position: absolute!important; top: 0; left: 0; clip: rect(1px, 1px, 1px, 1px); padding: 1px 0 0 0!important; border: 0!important; height: 1px!important; width: 1px!important; overflow: hidden!important; display: block!important; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none}
.MJX_Assistive_MathML.MJX_Assistive_MathML_Block {width: 100%!important}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1px; bottom: 2px; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><style type="text/css">.MJXp-script {font-size: .8em}
.MJXp-right {-webkit-transform-origin: right; -moz-transform-origin: right; -ms-transform-origin: right; -o-transform-origin: right; transform-origin: right}
.MJXp-bold {font-weight: bold}
.MJXp-italic {font-style: italic}
.MJXp-scr {font-family: MathJax_Script,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-frak {font-family: MathJax_Fraktur,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-sf {font-family: MathJax_SansSerif,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-cal {font-family: MathJax_Caligraphic,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-mono {font-family: MathJax_Typewriter,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-largeop {font-size: 150%}
.MJXp-largeop.MJXp-int {vertical-align: -.2em}
.MJXp-math {display: inline-block; line-height: 1.2; text-indent: 0; font-family: 'Times New Roman',Times,STIXGeneral,serif; white-space: nowrap; border-collapse: collapse}
.MJXp-display {display: block; text-align: center; margin: 1em 0}
.MJXp-math span {display: inline-block}
.MJXp-box {display: block!important; text-align: center}
.MJXp-box:after {content: " "}
.MJXp-rule {display: block!important; margin-top: .1em}
.MJXp-char {display: block!important}
.MJXp-mo {margin: 0 .15em}
.MJXp-mfrac {margin: 0 .125em; vertical-align: .25em}
.MJXp-denom {display: inline-table!important; width: 100%}
.MJXp-denom > * {display: table-row!important}
.MJXp-surd {vertical-align: top}
.MJXp-surd > * {display: block!important}
.MJXp-script-box > *  {display: table!important; height: 50%}
.MJXp-script-box > * > * {display: table-cell!important; vertical-align: top}
.MJXp-script-box > *:last-child > * {vertical-align: bottom}
.MJXp-script-box > * > * > * {display: block!important}
.MJXp-mphantom {visibility: hidden}
.MJXp-munderover {display: inline-table!important}
.MJXp-over {display: inline-block!important; text-align: center}
.MJXp-over > * {display: block!important}
.MJXp-munderover > * {display: table-row!important}
.MJXp-mtable {vertical-align: .25em; margin: 0 .125em}
.MJXp-mtable > * {display: inline-table!important; vertical-align: middle}
.MJXp-mtr {display: table-row!important}
.MJXp-mtd {display: table-cell!important; text-align: center; padding: .5em 0 0 .5em}
.MJXp-mtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-mlabeledtr {display: table-row!important}
.MJXp-mlabeledtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mlabeledtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MJXp-scale0 {-webkit-transform: scaleX(.0); -moz-transform: scaleX(.0); -ms-transform: scaleX(.0); -o-transform: scaleX(.0); transform: scaleX(.0)}
.MJXp-scale1 {-webkit-transform: scaleX(.1); -moz-transform: scaleX(.1); -ms-transform: scaleX(.1); -o-transform: scaleX(.1); transform: scaleX(.1)}
.MJXp-scale2 {-webkit-transform: scaleX(.2); -moz-transform: scaleX(.2); -ms-transform: scaleX(.2); -o-transform: scaleX(.2); transform: scaleX(.2)}
.MJXp-scale3 {-webkit-transform: scaleX(.3); -moz-transform: scaleX(.3); -ms-transform: scaleX(.3); -o-transform: scaleX(.3); transform: scaleX(.3)}
.MJXp-scale4 {-webkit-transform: scaleX(.4); -moz-transform: scaleX(.4); -ms-transform: scaleX(.4); -o-transform: scaleX(.4); transform: scaleX(.4)}
.MJXp-scale5 {-webkit-transform: scaleX(.5); -moz-transform: scaleX(.5); -ms-transform: scaleX(.5); -o-transform: scaleX(.5); transform: scaleX(.5)}
.MJXp-scale6 {-webkit-transform: scaleX(.6); -moz-transform: scaleX(.6); -ms-transform: scaleX(.6); -o-transform: scaleX(.6); transform: scaleX(.6)}
.MJXp-scale7 {-webkit-transform: scaleX(.7); -moz-transform: scaleX(.7); -ms-transform: scaleX(.7); -o-transform: scaleX(.7); transform: scaleX(.7)}
.MJXp-scale8 {-webkit-transform: scaleX(.8); -moz-transform: scaleX(.8); -ms-transform: scaleX(.8); -o-transform: scaleX(.8); transform: scaleX(.8)}
.MJXp-scale9 {-webkit-transform: scaleX(.9); -moz-transform: scaleX(.9); -ms-transform: scaleX(.9); -o-transform: scaleX(.9); transform: scaleX(.9)}
.MathJax_PHTML .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style></head><body><div id="MathJax_Message" style="display: none;"></div><div id="asciidoc0124_2"><div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_introduction">1. Introduction</a></li>
<li><a href="#_syntax">2. Syntax</a></li>
<li><a href="#_vocabulary_and_representation">3. Vocabulary and Representation</a>
<ul class="sectlevel2">
<li><a href="#_identifiers">3.1. Identifiers</a></li>
<li><a href="#_numbers">3.2. Numbers</a></li>
<li><a href="#_characters">3.3. Characters</a></li>
<li><a href="#_strings">3.4. Strings</a></li>
<li><a href="#_operators_and_delimiters">3.5. Operators and Delimiters</a></li>
<li><a href="#_reserved_words">3.6. Reserved Words</a></li>
<li><a href="#_comments">3.7. Comments</a></li>
</ul>
</li>
<li><a href="#_declarations_and_scope_rules">4. Declarations and scope rules</a></li>
<li><a href="#_constant_declarations">5. Constant declarations</a></li>
<li><a href="#_type_declarations">6. Type declarations</a>
<ul class="sectlevel2">
<li><a href="#_basic_types">6.1. Basic types</a></li>
<li><a href="#_array_types">6.2. Array types</a></li>
<li><a href="#_dictionary_types">6.3. Dictionary types</a></li>
<li><a href="#_record_types">6.4. Record types</a></li>
<li><a href="#_dynamic_allocation">6.5. Dynamic allocation</a></li>
<li><a href="#_procedure_types">6.6. Procedure types</a></li>
<li><a href="#_enumeration_types">6.7. Enumeration types</a></li>
</ul>
</li>
<li><a href="#_variable_declarations">7. Variable declarations</a></li>
<li><a href="#_expressions">8. Expressions</a>
<ul class="sectlevel2">
<li><a href="#_operands">8.1. Operands</a></li>
<li><a href="#_operators">8.2. Operators</a></li>
</ul>
</li>
<li><a href="#_statements">9. Statements</a>
<ul class="sectlevel2">
<li><a href="#_statement_sequences">9.1. Statement sequences</a></li>
<li><a href="#_assignments">9.2. Assignments</a></li>
<li><a href="#_procedure_calls">9.3. Procedure calls</a></li>
<li><a href="#_if_statements">9.4. If statements</a></li>
<li><a href="#_case_statements">9.5. Case statements</a></li>
<li><a href="#_while_statements">9.6. While statements</a></li>
<li><a href="#_repeat_statements">9.7. Repeat statements</a></li>
<li><a href="#_for_statements">9.8. For statements</a></li>
<li><a href="#_loop_statements">9.9. Loop statements</a></li>
<li><a href="#_return_and_exit_statements">9.10. Return and exit statements</a></li>
<li><a href="#_exception_handling">9.11. Exception handling</a></li>
</ul>
</li>
<li><a href="#_procedure_declarations">10. Procedure declarations</a>
<ul class="sectlevel2">
<li><a href="#_formal_parameters">10.1. Formal parameters</a></li>
<li><a href="#_type_bound_procedures">10.2. Type-bound procedures</a></li>
<li><a href="#_type_bound_procedure_types">10.3. Type-bound procedure types</a></li>
<li><a href="#_predeclared_procedures">10.4. Predeclared procedures</a></li>
</ul>
</li>
<li><a href="#_modules">11. Modules</a>
<ul class="sectlevel2">
<li><a href="#_generics">11.1. Generics</a></li>
</ul>
</li>
<li><a href="#_source_code_directives">12. Source code directives</a>
<ul class="sectlevel2">
<li><a href="#_configuration_variables">12.1. Configuration Variables</a></li>
<li><a href="#_conditional_compilation">12.2. Conditional compilation</a></li>
</ul>
</li>
<li><a href="#_definition_of_terms">Appendix A: Definition of terms</a></li>
<li><a href="#_syntax_of_luon">Appendix B: Syntax of Luon</a></li>
<li><a href="#_more_code_examples">Appendix C: More Code Examples</a></li>
<li><a href="#_references">Appendix D: References</a></li>
</ul>
</div>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This work is based on the language reports of Oberon+, Oberon-07 and Oberon-2.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_introduction">1. Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Luon is a general-purpose, procedural and object-oriented programming language in the tradition of Oberon+, Oberon-07 <a href="#Wi16">[Wi16]</a> and Oberon-2 <a href="#Mo91">[Mo91]</a>, with elements of Pascal <a href="#Wi73">[Wi73]</a>. Even though Luon has many similarities with those languages, backward compatibility is not a goal.</p>
</div>
<div class="paragraph">
<p>Luon is conceived as a statically typed alternative to scripting languages like e.g. Lua <a href="#Lua05">[Lua05]</a> and targets the virtual machines of such dynamic languages. The name "Luon" is a combination of "Lua" and "Oberon".</p>
</div>
<div class="paragraph">
<p>The most important features of Luon are block structure, modularity, separate compilation, static typing with strong type checking, generic programming <sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnote_1" title="View footnote.">1</a>]</sup>, garbage collection, and type extension with type-bound procedures.</p>
</div>
<div class="paragraph">
<p>The language allows several simplifications compared to previous Oberon versions: reserved words can be written in lower case, all semicolons are optional, and for some reserved words there are shorter variants; a declaration sequence can contain more than one CONST, TYPE and VAR section in arbitrary order, interleaved with procedures.</p>
</div>
<div class="paragraph">
<p>Furthermore, enumeration types, dictionary types, constructors, type-bound procedure types, explicit bit operations and exception handling have been added to the language.</p>
</div>
<div class="paragraph">
<p>This report is not intended as a programmerâ€™s tutorial. It is intentionally kept concise. Its function is to serve as a reference for programmers, implementors, and tutorial writers. What remains unsaid is mostly left so intentionally, either because it can be derived from stated rules of the language, or because it would require to commit the definition when a general commitment appears as unwise.</p>
</div>
<div id="luon-generics-example" class="listingblock">
<div class="title">Listing 1. Luon example featuring syntactic simplifications and type parameters</div>
<div class="content">
<pre class="highlight"><code class="language-luon" data-lang="luon">module Lists(T)
  type
    List* = record
               value* : T
               next*  : List
             end

  proc (l : List) Add* (v : T)
  begin
    new( l.next )
    l.next.value := v
  end Add

  proc (l : List) Print*()
  begin
    println(l.value)
  end Print
end Lists

module ListTest
  import
    L := Lists(integer)
  var
    l : L.List
  begin
    new(l)
    l.value := 123
    l.Add(456)
    l.Print()
    l.next.Print()
end ListTest</code></pre>
</div>
</div>
<div class="paragraph">
<p>See <a href="#oberon-2-example">here</a> for more examples.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_syntax">2. Syntax</h2>
<div class="sectionbody">
<div class="paragraph">
<p>An extended Backus-Naur Formalism (EBNF) is used to describe the syntax of Oberon+:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Alternatives are separated by <strong>|</strong>.</p>
</li>
<li>
<p>Brackets <strong>[</strong> and <strong>]</strong> denote optionality of the enclosed expression.</p>
</li>
<li>
<p>Braces <strong>{</strong> and <strong>}</strong> denote its repetition (possibly 0 times).</p>
</li>
<li>
<p>Syntactic entities (non-terminal symbols) are denoted by English words expressing their intuitive meaning.</p>
</li>
<li>
<p>Symbols of the language vocabulary (terminal symbols) are denoted by strings enclosed in quotation marks or by words in capital letters.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_vocabulary_and_representation">3. Vocabulary and Representation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Luon source code is a string of characters encoded using the UTF-8 variable-width encoding as defined in ISO/IEC 10646.
Identifiers, numbers, operators, and delimiters are represented using the ASCII character set; strings and comments can be either represented in the ASCII or Latin-1 character set.</p>
</div>
<div class="paragraph">
<p>The following lexical rules apply: blanks and line breaks must not occur within symbols (except in comments, and blanks in strings); they are ignored unless they are essential to separate two consecutive symbols. Capital and lower-case letters are considered as distinct.</p>
</div>
<div class="sect2">
<h3 id="_identifiers">3.1. Identifiers</h3>
<div class="paragraph">
<p>Identifiers are sequences of letters, digits and underscore. The first character must be a letter or an underscore.</p>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>ident  = ( letter | '_' ) { letter | digit | '_' }
letter = 'A' ... 'Z' | 'a' ... 'z'
digit  = '0' ... '9'</pre>
</div>
</div>
<div class="literalblock">
<div class="title">Examples:</div>
<div class="content">
<pre>x
Scan
Oberon_2
_y
firstLetter</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_numbers">3.2. Numbers</h3>
<div class="paragraph">
<p>Number literals are integer or real constants. The type of an integer literal is the minimal type to which the constant value belongs (see <a href="#_basic_types">Basic types</a>). If the literal is specified with the suffix <code>H</code> (or <code>h</code>), the representation is hexadecimal. If the literal is specified with the suffix <code>O</code> (or <code>o</code>), the representation is octal. If the literal is specified with the suffix <code>B</code> (or <code>b</code>), the representation is binary. Otherwise the representation is decimal. Integer literals can be interspersed with underscores for better readability.</p>
</div>
<div class="paragraph">
<p>A real number always contains a decimal point and at least one digit before the point. Optionally it may also contain a decimal scale factor. The letter <code>E</code> (or <code>e</code>) means <em>times ten to the power of</em>.</p>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>number   = integer | real
integer  = digit {hexDigit|'_'} ['O'|'B'|'H']
real     = digit {digit|'_'} '.' {digit|'_'} [Exponent]
Exponent = 'E' ['+' | '-'] digit {digit}
hexDigit = digit | 'A' ... 'F' | 'a' ... 'f'
digit    = '0' ... '9'</pre>
</div>
</div>
<div class="literalblock">
<div class="title">Examples:</div>
<div class="content">
<pre>1234
0dh              0DH
12.3
4.567e8          4.567E8
0.57712566d-6    0.57712566E-6</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_characters">3.3. Characters</h3>
<div class="paragraph">
<p>Character constants are denoted by the ordinal number of the character in hexadecimal notation followed by the letter <code>X</code> (or <code>x</code>).</p>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>character = digit {hexDigit} ('X' | 'x')</pre>
</div>
</div>
<div class="paragraph">
<p>A character is encoded as a 8-bit code value using the ISO/IEC 8859-1 Latin-1 encoding scheme.</p>
</div>
</div>
<div class="sect2">
<h3 id="_strings">3.4. Strings</h3>
<div class="paragraph">
<p>Strings are sequences of printable characters enclosed in single (') or double (") quote marks. The opening quote must be the same as the closing quote and must not occur within the string. A string must not extend over the end of a line. The number of characters in a string is called its length. A string of length 1 can be used wherever a character constant is allowed and vice versa.</p>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>string = ''' {character} ''' | '"' {character} '"'</pre>
</div>
</div>
<div class="literalblock">
<div class="title">Examples:</div>
<div class="content">
<pre>'Oberon'
"Don't worry!"
'x'</pre>
</div>
</div>
<div class="sect3">
<h4 id="_hex_strings">3.4.1. Hex Strings</h4>
<div class="paragraph">
<p>Hex strings are sequences of bytes encoded in hexadecimal format and enclosed in dollar signs. The number of hex digits in the string must be even, two hex digits per byte. The number of bytes in a hex string is called its length. Line breaks and other white space between the dollar signs is ignored.</p>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>hexstring = '$' {hexDigit} '$'</pre>
</div>
</div>
<div class="literalblock">
<div class="title">Examples:</div>
<div class="content">
<pre>const arrow = $0F0F 0060 0070 0038 001C 000E 0007 8003
			   C101 E300 7700 3F00 1F00 3F00 7F00 FF00$</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Hex strings are not specified in <a href="#Wi16">[Wi16]</a> but are used by the Project Oberon implementation, e.g. in Display.Mod. Hex strings are useful to represent all kinds of binary resources such as images and icons in the source code.
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_operators_and_delimiters">3.5. Operators and Delimiters</h3>
<div class="paragraph">
<p>Operators and delimiters are the special characters, or character pairs listed below.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.667%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">,</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:=</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">..</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">{</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">*</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">#</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">^</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;=</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">=</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&gt;=</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">|</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">~</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_reserved_words">3.6. Reserved Words</h3>
<div class="paragraph">
<p>The reserved words consist of either all capital or all lower case letters and cannot be used as identifiers. All words listed below are reserved (only capital letter versions shown).</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">AND</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ARRAY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BEGIN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CASE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CONST</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DIV</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ELSE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ELSIF</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">END</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">EXIT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">EXTERN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FALSE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FOR</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HASHMAP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IF</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IMPORT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INLINE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">INVAR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LOOP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MOD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MODULE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NIL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NOT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">OF</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">OR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PROC</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PROCEDURE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">RECORD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">REPEAT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">RETURN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">THEN</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">TO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TRUE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TYPE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">UNTIL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VAR</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
TRUE and FALSE are Oberon-07, Oberon+ and Luon reserved words, but just predeclared identifiers in Oberon-2. INLINE, INVAR, AND, NOT, EXTERN, HASHMAP and PROC are Luon reserved words not present in previous Oberon versions. Both, all lower-case and upper-case versions are only reserved words in Luon.
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_comments">3.7. Comments</h3>
<div class="paragraph">
<p>Comments are arbitrary character sequences opened by the bracket <code>(*</code> and closed by <code>*)</code>. Comments may be nested. They do not affect the meaning of a program. Luon also supports line comments; text starting with <code>//</code> up to a line break is considered a comment.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_declarations_and_scope_rules">4. Declarations and scope rules</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Every identifier occurring in a program must be introduced by a declaration, unless it is a predeclared identifier. Declarations also specify certain permanent properties of an object, such as whether it is a constant, a type, a variable, or a procedure. The identifier is then used to refer to the associated object.</p>
</div>
<div class="paragraph">
<p>The scope of an object x is the whole block (module, procedure, or record) to which the declaration belongs and hence to which the object is local. It excludes the scopes of equally named objects which are declared in nested blocks. The scope rules are:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>No identifier may denote more than one object within a given scope (i.e. no identifier may be declared twice in a block);</p>
</li>
<li>
<p>An object may only be referenced within its scope;</p>
</li>
<li>
<p>The order of declaration is not significant;</p>
</li>
<li>
<p>Identifiers denoting record fields (see <a href="#_record_types">Record types</a>) or type-bound procedures (see <a href="#_type_bound_procedures">Type-bound procedures</a>) are valid in record designators only.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>An identifier declared in a module block may be followed by an export mark (<code>*</code> or <code>-</code>) in its declaration to indicate that it is exported. An identifier <code>x</code> exported by a module <code>M</code> may be used in other modules, if they import <code>M</code> (see <a href="#_modules">Modules</a>). The identifier is then denoted as <code>M.x</code> in these modules and is called a qualified identifier. Identifiers marked with <code>-</code> in their declaration are read-only in importing modules.</p>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>qualident = [ident '.'] ident
identdef  = ident ['*' | '-']</pre>
</div>
</div>
<div class="paragraph">
<p>The following identifiers are predeclared; their meaning is defined in the indicated sections; either all capital or all lower case identifiers are supported (only capital versions shown).</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ABS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ANYREC</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ASSERT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BITAND</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BITASR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BITNOT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BITOR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BITS</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BITSHL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BITSHR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BITXOR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BOOLEAN</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BYTE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CAP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CAST</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CHAR</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CHR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CLIP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">COPY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DEC</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DEFAULT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">EXCL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FLOOR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FLT</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GETENV</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HALT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INC</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INCL</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">KEYS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LEN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MAX</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MIN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NEW</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ODD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ORD</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PCALL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PRINT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PRINTLN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">RAISE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">REAL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SETENV</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">STRING</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">STRLEN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TOSTRING</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TRAP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TRAPIF</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Both upper and lower-case versions are declare.
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_constant_declarations">5. Constant declarations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A constant declaration associates an identifier with a constant value.</p>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>ConstDeclaration = identdef '=' ConstExpression
ConstExpression  = expression</pre>
</div>
</div>
<div class="paragraph">
<p>A constant expression is an expression that can be evaluated by a mere textual scan without actually executing the program. Its operands are constants (see <a href="#_operands">Operands</a>) or predeclared functions (see <a href="#_predeclared_function_procedures">Predeclared function procedures</a>) that can be evaluated at compile time. Examples of constant declarations are:</p>
</div>
<div class="literalblock">
<div class="title">Examples:</div>
<div class="content">
<pre>N = 100
limit = 2*N - 1
fullSet = {min(set) .. max(set)}</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
For compile time calculations of values the same rules as for runtime calculation apply. The ConstExpression of ConstDeclaration behaves as if each use of the constant identifier was replaced by the ConstExpression.
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_type_declarations">6. Type declarations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A data type determines the set of values which variables of that type may assume, and the operators that are applicable. A type declaration associates an identifier with a type. In the case of structured types (arrays, dictionaries and records) it also defines the structure of variables of this type. In Luon, all structured types are allocated with NEW() or a constructor. Variables of structured types only contain a reference, not the value itself.</p>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>TypeDeclaration = identdef '=' type
type            = NamedType | ArrayType | DictType | RecordType  | ProcedureType | enumeration
NamedType       = qualident</pre>
</div>
</div>
<div class="literalblock">
<div class="title">Examples:</div>
<div class="content">
<pre>Table = array N of real
Node = record
  key: integer
  left, right: Tree
end
CenterTree = CenterNode
CenterNode = record (Node)
  width: integer
  subnode: Tree
end
Function = procedure(x: integer): integer</pre>
</div>
</div>
<div class="sect2">
<h3 id="_basic_types">6.1. Basic types</h3>
<div class="paragraph">
<p>The basic types are denoted by predeclared identifiers. The associated operators are defined in <a href="#_operators">Operators</a> and the predeclared function procedures in <a href="#_predeclared_procedures">Predeclared procedures</a>. Either all capital or all lower case identifiers are supported (only capital versions shown).</p>
</div>
<div class="paragraph">
<p>The values of the given basic types are the following:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 25%;">
<col style="width: 12.5%;">
<col style="width: 62.5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BOOLEAN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">the truth values true and false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BYTE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">the integers between 0 and 255</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CHAR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">the characters of the Latin-1 set (0x .. 0ffx)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">the integers between MIN(INTEGER) and MAX(INTEGER)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">REAL</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">an IEEE 754 floating point number</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">the sets of integers between 0 and MAX(SET)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>INTEGER, and BYTE are integer types, REAL is a floating point type, and together they are called numeric types. The larger type includes (the values of) the smaller type according to the following relations:</p>
</div>
<div id="type-inclusion-relations" class="literalblock">
<div class="content">
<pre>INTEGER &gt;= BYTE</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
In contrast to Oberon+ and earlier Oberon versions, integer and floating point types are not compatible, but require explicit conversion using FLT() and FLOOR(). Type inclusion is unidirectional, i.e. INTEGER includes BYTE but not vice versa - the latter requires explicit conversion using CLIP().
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_array_types">6.2. Array types</h3>
<div class="paragraph">
<p>An array is a structure consisting of a number of elements which are all of the same type, called the element type. The number of elements of an array is called its length. The length is a positive integer. The elements of the array are designated by indices, which are integers between 0 and the length minus 1.</p>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>ArrayType  = ARRAY [ length ] OF type | '[' [ length ] ']' type
length     = ConstExpression</pre>
</div>
</div>
<div class="paragraph">
<p>Arrays declared without length are called <em>open arrays</em>. They can be created for any size.</p>
</div>
<div class="literalblock">
<div class="title">Examples:</div>
<div class="content">
<pre>array 10 of integer
array of char
[N]T</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_dictionary_types">6.3. Dictionary types</h3>
<div class="paragraph">
<p>A dictionary is a structure consisting of arbitrary key-value pairs. The keys and values are all of the same type, called the key and value types. New values are added to the dictionary by assigning the value to a given key. If the value is the default value of the value type, the key-value pair is removed. Accordingly, if the dictionary is indexed with a non-existing key, the default value of the value type is returned. No particular order of the keys is assumed. The KEYS() predeclared function can be used to iterate over all keys included in the dictionary.</p>
</div>
<div class="literalblock">
<div class="title">Syntax</div>
<div class="content">
<pre>DictType = HASHMAP NamedType OF type</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_record_types">6.4. Record types</h3>
<div class="paragraph">
<p>A record type is a structure consisting of a fixed number of elements, called fields, with possibly different types. The record type declaration specifies the name and type of each field. The scope of the field identifiers extends from the point of their declaration to the end of the record type, but they are also visible within designators referring to elements of record variables (see <a href="#_operands">Operands</a>). If a record type is exported, field identifiers that are to be visible outside the declaring module must be marked. They are called public fields; unmarked elements are called private fields.</p>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>RecordType = RECORD ['(' BaseType ')']
             FieldList { [';'] FieldList} END
BaseType   = NamedType
FieldList  = [ IdentList ':' type ]
IdentList  = identdef { [','] identdef }</pre>
</div>
</div>
<div class="paragraph">
<p>Record types are extensible, i.e. a record type can be declared as an extension of another record type. In the example</p>
</div>
<div class="literalblock">
<div class="content">
<pre>T0 = record x: integer end
T1 = record (T0) y: real end</pre>
</div>
</div>
<div class="paragraph">
<p>T1 is a (direct) <em>extension</em> of T0 and T0 is the (direct) base type of T1 (see <a href="#_definition_of_terms">Definition of terms</a>). An extended type T1 consists of the fields of its base type and of the fields which are declared in T1. Fields declared in the extended record shadow equally named fields declared in a base type.</p>
</div>
<div class="paragraph">
<p>Each record is implicitly an extension of the predeclared record type ANYREC. ANYREC does not contain any fields and cannot be instantiated.</p>
</div>
<div class="literalblock">
<div class="title">Examples:</div>
<div class="content">
<pre>record
  day, month, year: integer
end

record
  name, firstname: array 32 of char
  age: integer
  salary: real
end</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_dynamic_allocation">6.5. Dynamic allocation</h3>
<div class="paragraph">
<p>All structured types are dynamically allocated. Variables of structured types are automatically initialized with NIL.</p>
</div>
<div class="paragraph">
<p>If p is a variable of a structured type, a call of the predeclared procedure <code>NEW(p)</code> (see <a href="#_predeclared_procedures">Predeclared procedures</a>) allocates a variable of type T on the heap. If T is a record type or an array type with fixed length, the allocation has to be done with <code>NEW(p)</code>; if T is an open array type the allocation has to be done with <code>NEW(p, e)</code> where T is allocated with length given by the expressions e. In either case a reference to the allocated instance is assigned to <code>p</code>. <code>p</code> is of type P.</p>
</div>
</div>
<div class="sect2">
<h3 id="_procedure_types">6.6. Procedure types</h3>
<div class="paragraph">
<p>Variables of a procedure type T have a procedure (or NIL) as value. If a procedure P is assigned to a variable of type T, the formal parameter lists and result types (see <a href="#_formal_parameters">Formal parameters</a>) of P and T must <em>match</em> (see <a href="#_definition_of_terms">Definition of terms</a>). A procedure P assigned to a variable or a formal parameter must not be a predeclared, nor a type-bound procedure.</p>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>ProcedureType = PROCEDURE [FormalParameters]</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_enumeration_types">6.7. Enumeration types</h3>
<div class="paragraph">
<p>An enumeration is a list of identifiers that denote the values which constitute a data type.
These identifiers are used as constants in the program. They, and no other values, belong to
this type. The values are ordered. and the ordering relation is defined by their sequence in
the enumeration. The ordinal number of the first value is O, but can be explicitly set to any integer.</p>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>enumeration = '('  ident [ '=' ConstExpression ] { [','] ident } ')'</pre>
</div>
</div>
<div class="literalblock">
<div class="title">Examples:</div>
<div class="content">
<pre>(red, green, blue)
(club, diamond, heart, spade)
(Monday = 1, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday)</pre>
</div>
</div>
<div class="paragraph">
<p>The ordinal number of an enumeration identifier can be obtained using the <code>ORD</code> predeclared function procedure, or by just assigning/passing to an integer type variable or parameter. <code>CAST</code> is the reverse operation. <code>MIN</code> returns the first and <code>MAX</code> the last ident of the enumeration. <code>INC</code> returns the next and <code>DEC</code> the previous ident. If T is an enumeration type then <code>INC(MAX(T))</code> and <code>DEC(MIN(T))</code> are undefined and terminate the program.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_variable_declarations">7. Variable declarations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Variable declarations introduce variables by defining an identifier and a data type for them.</p>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>VariableDeclaration = IdentList ":" type</pre>
</div>
</div>
<div class="paragraph">
<p>Record variables have both a static type (the type with which they are declared - simply called their type) and a dynamic type (the type of their value at run time). For variables and parameters of record type the dynamic type may be an extension of their static type. The static type determines which fields of a record are accessible. The dynamic type is used to call type-bound procedures (see <a href="#_type_bound_procedures">Type-bound procedures</a>).</p>
</div>
<div class="literalblock">
<div class="title">Examples:</div>
<div class="content">
<pre>i, j, k: integer
x, y: real
p, q: bool
s: set
F: Function
a: array 100 of real
w: array 16 of record
     name: array 32 of char
     count: integer
   end
t, c: Tree</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_expressions">8. Expressions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Expressions are constructs denoting rules of computation whereby constants and current values of variables are combined to compute other values by the application of operators and function procedures. Expressions consist of operands and operators. Parentheses may be used to express specific associations of operators and operands.</p>
</div>
<div class="sect2">
<h3 id="_operands">8.1. Operands</h3>
<div class="paragraph">
<p>With the exception of set constructors and literal constants (numbers, character constants, or strings), operands are denoted by designators. A designator consists of an identifier referring to a constant, variable, or procedure. This identifier may possibly be qualified by a module identifier (see <a href="#_declarations_and_scope_rules">Declarations and scope rules</a> and <a href="#_modules">Modules</a>) and may be followed by selectors if the designated object is an element of a structure.</p>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>designator = qualident {selector}
selector   = '.' ident ['^'] | '[' expression ']' | '(' [ ExpList ] ')'
ExpList    = expression {',' expression}</pre>
</div>
</div>
<div class="paragraph">
<p>If <code>a</code> designates an array, then <code>a[e]</code> denotes that element of <code>a</code> whose index is the current value of the expression <code>e</code>. The type of <code>e</code> must be an <em>integer type</em>.</p>
</div>
<div class="paragraph">
<p>If <code>r</code> designates a record, then <code>r.f</code> denotes the field <code>f</code> of <code>r</code> or the procedure <code>f</code> bound to the dynamic type of <code>r</code> (see <a href="#_type_bound_procedures">Type-bound procedures</a>).</p>
</div>
<div class="paragraph">
<p>If <code>a</code> or <code>r</code> are read-only, then also <code>a[e]</code> and <code>r.f</code> are read-only.</p>
</div>
<div class="paragraph">
<p>A type guard <code>v(T)</code> asserts that the dynamic type of <code>v</code> is T (or an extension of T), i.e. program execution is aborted, if the dynamic type of <code>v</code> is not T (or an extension of T). Within the designator, <code>v</code> is then regarded as having the static type T. The guard is applicable, if</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>v</code> is a variable or parameter of record type, and if</p>
</li>
<li>
<p>T is an extension of the static type of <code>v</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If the designated object is a constant or a variable, then the designator refers to its current value. If it is a procedure, the designator refers to that procedure unless it is followed by a (possibly empty) parameter list in which case it implies an activation of that procedure and stands for the value resulting from its execution. The actual parameters must correspond to the formal parameters as in proper procedure calls (see <a href="#_formal_parameters">Formal parameters</a>).</p>
</div>
<div class="literalblock">
<div class="title">Examples:</div>
<div class="content">
<pre>i                        // integer
a[i]                     // real
w[3].name[i]             // char
t.left.right             // Tree
t(CenterTree).subnode    // Tree</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_operators">8.2. Operators</h3>
<div class="paragraph">
<p>Four classes of operators with different precedences (binding strengths) are syntactically distinguished in expressions. The operator <code>~</code> has the highest precedence, followed by multiplication operators, addition operators, and relations. Operators of the same precedence associate from left to right. For example, <code>x-y-z</code> stands for <code>(x-y)-z</code>.</p>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>expression       = SimpleExpression [ relation SimpleExpression ]
relation         = '=' | '#' | '&lt;' | '&lt;=' | '&gt;' | '&gt;=' | IN | IS
SimpleExpression = ['+' | '-'] term { AddOperator term }
AddOperator      = '+' | '-' | OR
term             = factor {MulOperator factor}
MulOperator      = '*' | '/' | DIV | MOD | '&amp;' | AND
literal          = number | string | hexstring | hexchar
                   | NIL | TRUE | FALSE | set
factor           = literal | designator [ActualParameters]
	               | '(' expression ')' | ['~' | NOT] factor
ActualParameters = '(' [ ExpList ] ')'
set              = '{' [ element {',' element} ] '}'
element          = expression ['..' expression]</pre>
</div>
</div>
<div class="sect3">
<h4 id="_logical_operators">8.2.1. Logical operators</h4>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 33.3333%;">
<col style="width: 16.6666%;">
<col style="width: 33.3335%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">OR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">logical disjunction</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>p or q</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>if p then TRUE, else q</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&amp;, AND</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">logical conjunction</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>p &amp; q</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>if p then q, else FALSE</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">~, NOT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">negation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>~p</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>not p</em></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>These operators apply to BOOLEAN operands and yield a BOOLEAN result.</p>
</div>
</div>
<div class="sect3">
<h4 id="_arithmetic_operators">8.2.2. Arithmetic operators</h4>
<table class="tableblock frame-all grid-all" style="width: 50%;">
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sum</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">difference</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">*</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">product</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">real quotient</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DIV</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer quotient</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MOD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">modulus</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The operators <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code> apply to operands of numeric types. The type of the result is the type of that operand which includes the type of the other operand, except for division (<code>/</code>), where the result is the smallest real type which includes both operand types. When used as monadic operators, <code>-</code> denotes sign inversion and <code>+</code> denotes the identity operation. The operators <code>DIV</code> and <code>MOD</code> apply to integer operands only. They are related by the following formulas defined for any <code>x</code> and positive divisors <code>y</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>x = (x DIV y) * y + (x MOD y)
0 &lt;= (x MOD y) &lt; y</pre>
</div>
</div>
<div class="literalblock">
<div class="title">Examples:</div>
<div class="content">
<pre>x    y    x DIV y    x MOD y
5    3    1          2
-5   3    -2         1</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_set_operators">8.2.3. Set Operators</h4>
<table class="tableblock frame-all grid-all" style="width: 70%;">
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">union</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">difference (x - y = x * (-y))</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">*</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">intersection</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">symmetric set difference (x / y = (x-y) + (y-x))</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Set operators apply to operands of type SET and yield a result of type SET. The monadic minus sign denotes the complement of <code>x</code>, i.e. <code>-x</code> denotes the set of integers between 0 and <code>MAX(SET)</code> which are not elements of <code>x</code>. Set operators are not associative (<code>(a+b)-c # a+(b-c)</code>).</p>
</div>
<div class="paragraph">
<p>A set constructor defines the value of a set by listing its elements between curly brackets. The elements must be integers in the range <code>0..MAX(SET)</code>. A range <code>a..b</code> denotes all integers in the interval [a, b]. See also <a href="#_constructors">Constructors</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_relations">8.2.4. Relations</h4>
<table class="tableblock frame-all grid-all" style="width: 50%;">
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">=</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">equal</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">#</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">unequal</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">less</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;=</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">less or equal</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">greater</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&gt;=</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">greater or equal</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">IN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">set membership</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">IS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">type test</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Relations yield a BOOLEAN result. The relations <code>=</code>, <code>#</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> apply to the numeric types, as well as enumerations, CHAR, strings, and CHAR arrays containing <code>0x</code> as a terminator. The relations <code>=</code> and <code>#</code> also apply to BOOLEAN and SET, as well as to structured and procedure types (including the value NIL). <code>x IN s</code> stands for <em>x is an element of s</em>. <code>x</code> must be of an integer type, and <code>s</code> of type SET. <code>v IS T</code> stands for <em>the dynamic type of <code>v</code> is T (or an extension of T )</em> and is called a type test. It is applicable if</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>v</code> is a variable or parameter of record type (which can be NIL), and if</p>
</li>
<li>
<p>T is an <em>extension</em> of the static type of <code>v</code> (see <a href="#_definition_of_terms">Definition of terms</a>).</p>
</li>
</ol>
</div>
<div class="literalblock">
<div class="title">Examples:</div>
<div class="content">
<pre>1991                   // integer
i div 3                // integer
~p or q                // boolean
(i+j) * (i-j)          // integer
s - {8, 9, 13}         // set
i + x                  // real
a[i+j] * a[i-j]        // real
(0&lt;=i) &amp; (i&lt;100)       // boolean
t.key = 0              // boolean
k in {i..j-1}          // boolean
w[i].name &lt;= "John"    // boolean
t is CenterTree        // boolean</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_string_operators">8.2.5. String operators</h4>
<table class="tableblock frame-all grid-all" style="width: 50%;">
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">concatenation</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The concatenation operator applies to operands of string types (literals as well as char arrays and STRING types). The resulting string consists of the characters of the first operand followed by the characters of the second operand.</p>
</div>
</div>
<div class="sect3">
<h4 id="_constructors">8.2.6. Constructors</h4>
<div class="paragraph">
<p>A constructor consists of an (optional) explicit type and a list of either named or anonymous components. Named and anonymous components cannot be mixed in the list. Constructors are used to create an instance of the given structured type.
If NamedType is a record type, then there is either an anonymous component for each field of the record in the order of declaration, or there is a named component for each field in arbitrary order. If the record type has a variant part, only named component can be used, and only one option of the variant part can be initialized in the constructor.
If NamedType is an array type, then there is an anonymous or index componend for each element of the array. The array type may be an open array in which case the number of elements is determined by the number of components.
If NamedType is a dictionary, then there is an index component for each element to be added to the dictionary.
For each field or element which is of record, array or dictionary type, an embedded constructor is required. Since the exact type of the field or element is known, the NamedType prefix can be left out.
If NamedType is a SET type, then there is an anonymous or range component to specify the elements to be incuded in the set.
If a constructor is used in an assigment or as an actual parameter, the NamedType prefix can be left out, and the type is inferred from the left side of the assignment or the formal parameter. For SET constructors, the NamedType can always be left out.</p>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>constructor = NamedType '{' [ component {[','] component} ] '}'
component = ident ':' expression | '[' expression ']' ':' expression | expression | expression '..' expression</pre>
</div>
</div>
<div class="literalblock">
<div class="title">Example:</div>
<div class="content">
<pre>myVal := Rect{0,0,x1,y1};</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_function_call">8.2.7. Function Call</h4>
<div class="paragraph">
<p>A function call is a factor in an expression. In contrast to <a href="#_procedure_calls">Procedure calls</a> in a function call the actual parameter list is mandatory. Each expression in the actual parameters list (if any) is used to initialize a corresponding formal parameter. The number of expressions in the actual parameter list must correspond the number of formal parameters. See also <a href="#_formal_parameters">Formal parameters</a>.</p>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>FunctionCall           = designator ActualParameters
ActualParameters = '(' [ ExpList ] ')'</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_statements">9. Statements</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Statements denote actions. There are elementary and structured statements. Elementary statements are not composed of any parts that are themselves statements. They are the assignment, the procedure call, the return, and the <code>exit</code> statement. Structured statements are composed of parts that are themselves statements. They are used to express sequencing and conditional, selective, and repetitive execution.</p>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>statement = [ assignment | ProcedureCall | IfStatement
            | CaseStatement  | LoopStatement
            | ExitStatement | ReturnStatement | WhileStatement
	        | RepeatStatement | ForStatement ]</pre>
</div>
</div>
<div class="sect2">
<h3 id="_statement_sequences">9.1. Statement sequences</h3>
<div class="paragraph">
<p>Statement sequences denote the sequence of actions specified by the component statements which are optionally separated by semicolons.</p>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>StatementSequence = statement { [";"] statement}</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_assignments">9.2. Assignments</h3>
<div class="paragraph">
<p>Assignments replace the current value of a variable by a new value specified by an expression. The expression must be <em>assignment compatible</em> with the variable (see <a href="#_definition_of_terms">Definition of terms</a>). The assignment operator is written as <code>:=</code> and pronounced as <em>becomes</em>.</p>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>assignment = designator ':=' expression</pre>
</div>
</div>
<div class="paragraph">
<p>If an expression <code>e</code> of type T<sub>e</sub> is assigned to a variable <code>v</code> of type T<sub>v</sub>, the following happens:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>if T<sub>v</sub> and T<sub>e</sub> are structured types, only the reference to the structured type instance is copied;</p>
</li>
<li>
<p>if the dynamic type of <code>v</code> must be the same as the static type of <code>v</code> and is not changed by the assignment;</p>
</li>
<li>
<p>if T<sub>v</sub> is <code>ARRAY n OF CHAR</code> and <code>e</code> is a string literal or STRING of length m &lt; n, <code>v[i]</code> becomes e<sub>i</sub> for i = 0..m-1 and <code>v[m]</code> becomes 0X;</p>
</li>
<li>
<p>if T<sub>v</sub> is an open CHAR array and <code>e</code> is a string literal or STRING, <code>v[i]</code> becomes <code>e[i]</code> for i = 0..STRLEN(e); if LEN(v) &lt;= STRLEN(e) or <code>e</code> is not terminated by 0X the program halts.</p>
</li>
</ol>
</div>
<div class="literalblock">
<div class="title">Examples:</div>
<div class="content">
<pre>i := 0
p := i = j
x := i + 1
k := log2(i+j)
F := log2
s := {2, 3, 5, 7, 11, 13}
a[i] := (x+y) * (x-y)
t.key := i
w[i+1].name := "John"
t := c</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_procedure_calls">9.3. Procedure calls</h3>
<div class="paragraph">
<p>A procedure call activates a procedure. It may contain a list of actual parameters which replace the corresponding formal parameter list defined in the procedure declaration (see <a href="#_procedure_declarations">Procedure declarations</a>). The correspondence is established by the positions of the parameters in the actual and formal parameter lists. There are three kinds of parameters: <em>variable</em> (VAR), CONST and <em>value</em> parameters.</p>
</div>
<div class="paragraph">
<p>If a formal parameter is a VAR parameter, the corresponding actual parameter must be a designator denoting a variable. If it denotes an element of a structured variable, the component selectors are evaluated when the formal/actual parameter substitution takes place, i.e. before the execution of the procedure. If the formal parameter is CONST, then the designated variable, element or field is read-only within the procedure. If a formal parameter is a value parameter, the corresponding actual parameter must be an expression. This expression is evaluated before the procedure activation, and the resulting value is assigned to the formal parameter (see also <a href="#_formal_parameters">Formal parameters</a>).</p>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>ProcedureCall = designator [ ActualParameters ]</pre>
</div>
</div>
<div class="literalblock">
<div class="title">Examples:</div>
<div class="content">
<pre>WriteInt(i*2+1)
inc(w[k].count)
t.Insert("John")</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_if_statements">9.4. If statements</h3>
<div class="paragraph">
<p>If statements specify the conditional execution of guarded statement sequences. The boolean expression preceding a statement sequence is called its guard. The guards are evaluated in sequence of occurrence, until one evaluates to TRUE, whereafter its associated statement sequence is executed. If no guard is satisfied, the statement sequence following the symbol ELSE is executed, if there is one.</p>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>IfStatement    = IF expression THEN StatementSequence
	             {ElsifStatement} [ElseStatement] END
ElsifStatement = ELSIF expression THEN StatementSequence
ElseStatement  = ELSE StatementSequence</pre>
</div>
</div>
<div class="literalblock">
<div class="title">Example:</div>
<div class="content">
<pre>if (ch &gt;= "A") &amp; (ch &lt;= "Z") then ReadIdentifier
elsif (ch &gt;= "0") AND (ch &lt;= "9") then ReadNumber
elsif (ch = "'") OR (ch = '"') then ReadString
else SpecialCharacter
end</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_case_statements">9.5. Case statements</h3>
<div class="paragraph">
<p>Case statements specify the selection and execution of a statement sequence according to the value of an expression. First the case expression is evaluated, then that statement sequence is executed whose case label list contains the obtained value. The case expression must either be of an integer type that includes the types of all case labels, or an enumeration type with all case labels being valid members of this type, or both the case expression and the case labels must be of type CHAR. Case labels are constants, and no value must occur more than once. If the value of the expression does not occur as a label of any case, the statement sequence following the symbol ELSE is selected, if there is one, otherwise the program is aborted.</p>
</div>
<div class="paragraph">
<p>The type T of the case expression (case variable) may also be a variable parameter of record type variable. Then each case consists of exactly one case label which must be an <em>extension</em> of T (see <a href="#_definition_of_terms">Definition of terms</a>), and in the statements S<sub>i</sub> labelled by T<sub>i</sub>, the case variable is considered as of type T<sub>i</sub>. The evaluation order corresponds to the case label order; the first statement sequence is executed whose case label meets the condition.</p>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>CaseStatement = CASE expression OF ['|'] Case { '|' Case }
	            [ ELSE StatementSequence ] END
Case          = [ CaseLabelList ':' StatementSequence ]
CaseLabelList = LabelRange { ',' LabelRange }
LabelRange    = label [ '..' label ]
label         = ConstExpression</pre>
</div>
</div>
<div class="literalblock">
<div class="title">Examples:</div>
<div class="content">
<pre>case ch of
  "A" .. "Z": ReadIdentifier
| "0" .. "9": ReadNumber
| "'", '"': ReadString
else SpecialCharacter
end

type R  = record a: integer end
	 R0 = record (R) b: integer end
	 R1 = record (R) b: real end
	 R2 = record (R) b: set end
	 P  = R
	 P0 = R0
	 P1 = R1
	 P2 = R2
var p: P
case p of
	| P0: p.b := 10
	| P1: p.b := 2.5
	| P2: p.b := {0, 2}
	| NIL: p.b := {}
end</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_while_statements">9.6. While statements</h3>
<div class="paragraph">
<p>While statements specify the repeated execution of a statement sequence while the Boolean expression (its guard) yields TRUE. The guard is checked before every execution of the statement sequence.</p>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>WhileStatement = WHILE expression DO StatementSequence END</pre>
</div>
</div>
<div class="literalblock">
<div class="title">Examples:</div>
<div class="content">
<pre>while i &gt; 0 do i := i div 2; k := k + 1 end

while (t # nil) &amp; (t.key # i) do t := t.left end</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_repeat_statements">9.7. Repeat statements</h3>
<div class="paragraph">
<p>A repeat statement specifies the repeated execution of a statement sequence until a condition specified by a Boolean expression is satisfied. The statement sequence is executed at least once.</p>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>RepeatStatement = REPEAT StatementSequence UNTIL expression</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_for_statements">9.8. For statements</h3>
<div class="paragraph">
<p>A for statement specifies the repeated execution of a statement sequence while a progression of values is assigned to a control variable of the for statement. Control variables can be of integer or enumeration types. An explicit BY expression is only supported for integer control variables.</p>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>ForStatement = FOR ident ':=' expression TO expression
			   [BY ConstExpression]
	           DO StatementSequence END</pre>
</div>
</div>
<div class="paragraph">
<p>The statement</p>
</div>
<div class="literalblock">
<div class="content">
<pre>for v := first to last by step do statements end</pre>
</div>
</div>
<div class="paragraph">
<p>is equivalent to</p>
</div>
<div class="literalblock">
<div class="content">
<pre>temp := last; v := first
if step &gt; 0 then
    while v &lt;= temp do statements; INC(v,step) end
else
    while v &gt;= temp do statements; DEC(v,-step) end
end</pre>
</div>
</div>
<div class="paragraph">
<p>temp has the same type as <code>v</code>. For integer control variables, step must be a nonzero constant expression; if step is not specified, it is assumed to be 1. For enumeration control variables, there is no explicit step, but the INC or DEC version of the while loop is used depending on ORD(first) â‡ ORD(last).</p>
</div>
<div class="literalblock">
<div class="title">Examples:</div>
<div class="content">
<pre>for i := 0 to 79 do k := k + a[i] end
for i := 79 to 1 by -1 do a[i] := a[i-1] end</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_loop_statements">9.9. Loop statements</h3>
<div class="paragraph">
<p>A loop statement specifies the repeated execution of a statement sequence. It is terminated upon execution of an exit statement within that sequence (see <a href="#_return_and_exit_statements">Return and exit statements</a>).</p>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>LoopStatement = LOOP StatementSequence END
ExitStatement = EXIT</pre>
</div>
</div>
<div class="literalblock">
<div class="title">Example:</div>
<div class="content">
<pre>loop
  ReadInt(i)
  if i &lt; 0 then exit end
  WriteInt(i)
end</pre>
</div>
</div>
<div class="paragraph">
<p>Loop statements are useful to express repetitions with several exit points or cases where the exit condition is in the middle of the repeated statement sequence.</p>
</div>
</div>
<div class="sect2">
<h3 id="_return_and_exit_statements">9.10. Return and exit statements</h3>
<div class="paragraph">
<p>A return statement indicates the termination of a procedure. It is denoted by the symbol RETURN, followed by an expression if the procedure is a function procedure. The type of the expression must be assignment compatible (see <a href="#_definition_of_terms">Definition of terms</a>) with the result type specified in the procedure heading (see <a href="#_procedure_declarations">Procedure declarations</a>).</p>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>ReturnStatement = RETURN [ expression ]
ExitStatement   = EXIT</pre>
</div>
</div>
<div class="paragraph">
<p>Function procedures require the presence of a return statement indicating the result value. In proper procedures, a return statement is implied by the end of the procedure body. Any explicit return statement therefore appears as an additional (probably exceptional) termination point.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The optional expression causes an LL(k) ambiguity which can be resolved in that the parser expects a return expression if the procedure has a return type and vice versa.
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>An exit statement is denoted by the symbol EXIT. It specifies termination of the enclosing loop statement and continuation with the statement following that loop statement. Exit statements are contextually, although not syntactically associated with the loop statement which contains them.</p>
</div>
</div>
<div class="sect2">
<h3 id="_exception_handling">9.11. Exception handling</h3>
<div class="paragraph">
<p>Exception handling is implemented using the predeclared procedures PCALL and RAISE (see <a href="#_predeclared_proper_procedures">Predeclared proper procedures</a>), without any special syntax. There are no predefined exceptions.</p>
</div>
<div class="paragraph">
<p>An exception is a record. This record is passed as an actual argument to RAISE. If the argument is nil instead, the program execution aborts. RAISE may be called without an argument in which case the compiler provides an allocated record the exact type of which is not relevant. RAISE never returns, but control is transferred from the place where RAISE is called to the nearest dynamically-enclosing call of PCALL. When calling RAISE without a dynamically-enclosing call of PCALL the program execution is aborted.</p>
</div>
<div class="paragraph">
<p>PCALL executes a protected call of the procedure or procedure type P. P is passed as the second argument to PCALL. P cannot have a return type. P can be a type-bound procedure type. P can be a nested procedure, even if it accesses local variables or parameters of an outer procedure. If P has formal parameters the corresponding actual parameters are passed to PCALL immediately after P. The actual parameters must be <em>parameter compatible</em> with the formal parameters of P (see <a href="#_definition_of_terms">Definition of terms</a>). The first parameter R of PCALL is of type ANYREC; if RAISE(E) is called in the course of P, then R is set to E; otherwise R is set to NIL. The state of VAR parameters of P or local variables or parameters of an outer procedure accessed by P is non-deterministic in case RAISE is called in the course of P.</p>
</div>
<div class="listingblock">
<div class="title">Listing 2. Example:</div>
<div class="content">
<pre>module ExceptionExample
  type Exception = record end
  proc Print(in str: array of char)
    var e: Exception
  begin
    println(str)
    new(e)
    raise(e)
    println("this is not printed")
  end Print
  var res: anyrec
begin
  pcall(res, Print, "Hello World")
  case res of
  | Exception: println("got Exception")
  | anyrec: println("got anyrec")
  | nil: println("no exception")
  else
    println("unknown exception")
    // could call raise(res) here to propagate the exception
  end
end ExceptionExample</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_procedure_declarations">10. Procedure declarations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A procedure declaration consists of a procedure heading and a procedure body. The heading specifies the procedure identifier and the formal parameters (see <a href="#Formal Parameters">[Formal Parameters]</a>). For type-bound procedures it also specifies the receiver parameter. The body contains declarations and statements. The procedure identifier must be repeated at the end of the procedure declaration unless it has no body.</p>
</div>
<div class="paragraph">
<p>There are two kinds of procedures: proper procedures and function procedures. The latter are activated by a function designator as a constituent of an expression and yield a result that is an operand of the expression. Proper procedures are activated by a procedure call. A procedure is a function procedure if its formal parameters specify a result type. Each control path of a function procedure must return a value.</p>
</div>
<div class="paragraph">
<p>All constants, variables, types, and procedures declared within a procedure body are local to the procedure. Since procedures may be declared as local objects too, procedure declarations may be nested. The call of a procedure within its declaration implies recursive activation.</p>
</div>
<div class="paragraph">
<p>Nested procedures can access the constant, type and procedure declarations of the surrounding procedures, but neither their local variables or parameter.</p>
</div>
<div class="paragraph">
<p>A procedure body may have no statements in which case the ident after the END reserved word can also be left out; in a function procedure with no statements a return statement with a default value is assumed.</p>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>ProcedureDeclaration = ProcedureHeading (
						[ ';' ] 'EXTERN
						| [INLINE] [ ';' ] (ProcedureBody | END )
ProcedureHeading     = ( PROCEDURE | PROC )
					   [Receiver] identdef [ FormalParameters ]
ProcedureBody        = DeclarationSequence block END ident
block 				= BEGIN StatementSequence
Receiver             = '(' ident ':' ident ')'
DeclarationSequence  = { CONST { ConstDeclaration [';'] }
					   | TYPE { TypeDeclaration [';'] }
					   | VAR { VariableDeclaration [';'] }
					   | ProcedureDeclaration [';'] }</pre>
</div>
</div>
<div class="paragraph">
<p>If a procedure declaration specifies a receiver parameter, the procedure is considered to be bound to a type (see <a href="#_type_bound_procedures">Type-bound procedures</a>).</p>
</div>
<div class="sect2">
<h3 id="_formal_parameters">10.1. Formal parameters</h3>
<div class="paragraph">
<p>Formal parameters are identifiers declared in the formal parameter list of a procedure. They correspond to actual parameters specified in the procedure call. The correspondence between formal and actual parameters is established when the procedure is called. There are three kinds of parameters, value, variable (VAR) and CONST parameters, indicated in the formal parameter list by the absence or presence of the reserved words VAR and CONST.</p>
</div>
<div class="paragraph">
<p>Value parameters are local variables to which the value of the corresponding actual parameter is assigned as an initial value. VAR parameters correspond to actual parameters that are variables, and they stand for these variables.</p>
</div>
<div class="paragraph">
<p>CONST parameters are like value parameters, but they are read-only in the procedure body. If a CONST parameters is of structured type, then also the elements or fields are transitively read-only in the procedure body.</p>
</div>
<div class="paragraph">
<p>The scope of a formal parameter extends from its declaration to the end of the procedure block in which it is declared. A function procedure without parameters must have an empty parameter list. It must be called by a function designator whose actual parameter list is empty too.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The return type of a procedure may also be a structured type, and it is possible to ignore the return value of a function procedure call.
</td>
</tr>
</tbody></table>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>FormalParameters = '(' [ FPSection { [';'] FPSection } ] ')'
                   [ ':' ReturnType ]
ReturnType       = NamedType
FPSection        = [ VAR | CONST ] ident { [','] ident }
                   ':' FormalType
FormalType       = type</pre>
</div>
</div>
<div class="literalblock">
<div class="title">Examples:</div>
<div class="content">
<pre>proc ReadInt(var x: integer)
  var i: integer; ch: char
begin i := 0; Read(ch)
  while ("0" &lt;= ch) &amp; (ch &lt;= "9") do
    i := 10*i + (ord(ch)-ord("0")); Read(ch)
  end
  x := i
end ReadInt

proc WriteInt(x: integer) // 0 &lt;= x &lt;100000
var i: integer; buf: [5]integer
begin i := 0
  repeat buf[i] := x mod 10; x := x div 10; inc(i) until x = 0
  repeat dec(i); Write(chr(buf[i] + ord("0"))) until i = 0
end WriteInt

proc WriteString(s: []char)
  var i: integer
begin i := 0
  while (i &lt; len(s)) &amp; (s[i] # 0x) do Write(s[i]); inc(i) end
end WriteString

proc log2(x: integer): integer
  var y: integer // assume x&gt;0
begin
  y := 0; while x &gt; 1 do x := x div 2; inc(y) end
  return y
end log2</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_type_bound_procedures">10.2. Type-bound procedures</h3>
<div class="paragraph">
<p>Procedures may be associated with a record type declared in the same scope. The procedures are said to be bound to the record type. The binding is expressed by the type of the receiver in the heading of a procedure declaration. The procedure is bound to the type T and is considered local to it.</p>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>ProcedureHeading = ( PROCEDURE | PROC )
				   [Receiver] identdef [ FormalParameters ]
Receiver         = '(' ident ':' ident ')'</pre>
</div>
</div>
<div class="paragraph">
<p>If a procedure P is bound to a type T0, it is implicitly also bound to any type T1 which is an extension of T0. However, a procedure P' (with the same name as P) may be explicitly bound to T1 in which case it overrides the binding of P. P' is considered a redefinition of P for T1. The formal parameters of P and P' must <em>match</em> (see <a href="#_definition_of_terms">Definition of terms</a>). If P and T1 are exported (see <a href="#_declarations_and_scope_rules">Declarations and scope rules</a>), P' must be exported too.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The name of a type-bound procedure must be unique within the type to which it is bound, not within the scope in which it is declared.
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>If <code>v</code> is a designator and <code>P</code> is a type-bound procedure, then <code>v.P</code> denotes that procedure <code>P</code> which is bound to the dynamic type of <code>v</code>. Note, that this may be a different procedure than the one bound to the static type of <code>v</code>. <code>v</code> is passed to `Pâ€™s receiver according to the parameter passing rules specified in Chapter <a href="#_formal_parameters">Formal parameters</a>.</p>
</div>
<div class="paragraph">
<p>If <code>r</code> is the receiver parameter of P declared with type T, <code>r.P^</code> denotes the (redefined, sometimes calles <em>super</em>) procedure P bound to a base type of T.</p>
</div>
<div class="literalblock">
<div class="title">Examples:</div>
<div class="content">
<pre>proc (t: Tree) Insert (node: Tree)
  var p, father: Tree
begin p := t
  repeat father := p
    if node.key = p.key then return end
    if node.key &lt; p.key then
      p := p.left
    else
      p := p.right
    end
  until p = nil
  if node.key &lt; father.key then
    father.left := node
  else
    father.right := node
  end
  node.left := nil; node.right := nil
end Insert

proc (t: CenterTree) Insert (node: Tree) // redefinition
begin
  WriteInt(node(CenterTree).width)
  t.Insert^(node)  // calls the Insert procedure bound to Tree
end Insert</pre>
</div>
</div>
<div class="paragraph">
<p>Type-bound procedure declarations may be nested and have access to constants, types and procedures declared in the environment of the type-bound procedure (unless concealed by a local declaration), but they donâ€™t have access to the parameters or local variables of outer procedures.</p>
</div>
</div>
<div class="sect2">
<h3 id="_type_bound_procedure_types">10.3. Type-bound procedure types</h3>
<div class="paragraph">
<p>Variables of a type-bound procedure type T have a type-bound procedure or NIL as value. To assign a type-bound procedure P to a variable of a type-bound procedure type T, the right side of the assignment must be a designator of the form <code>v.P</code>, where <code>v</code> is a record and <code>P</code> is a procedure bound to this record. Note, that the dynamic type of <code>v</code> determines which procedure is assigned; this may be a different procedure than the one bound to the static type of <code>v</code>. The formal parameter lists and result types (see <a href="#_formal_parameters">Formal parameters</a>) of P and T must <em>match</em> (see <a href="#_definition_of_terms">Definition of terms</a>). The same rules apply when passing a type-bound procedure to a formal argument of a type-bound procedure type.</p>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>ProcedureType = PROCEDURE '^' [FormalParameters]</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_predeclared_procedures">10.4. Predeclared procedures</h3>
<div class="paragraph">
<p>The following table lists the predeclared procedures. Some are generic procedures, i.e. they apply to several types of operands. <code>v</code> stands for a variable, <code>x</code> and <code>n</code> for expressions, and T for a type.</p>
</div>
<div class="sect3">
<h4 id="_predeclared_function_procedures">10.4.1. Predeclared function procedures</h4>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 12.5%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 37.5%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Argument type</th>
<th class="tableblock halign-left valign-top">Result type</th>
<th class="tableblock halign-left valign-top">Function</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ABS(x)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">numeric type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">type of x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">absolute value</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CAP(x)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CHAR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CHAR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">corresponding capital letter (only for the ASCII subset of the CHAR type)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BITAND(x,y)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x, y: INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bitwise AND; all bit operations support at least MAX(SET)+1 bits resolution</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BITASR(x,n)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x, n: INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">arithmetic shift right by n bits, where n &gt;= 0 and n â‡ MAX(SET)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BITNOT(x)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x: INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bitwise NOT</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BITOR(x,y)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x, y: INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bitwise OR</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BITS(x)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x: INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">set corresponding to the integer; the first element corresponds to the least significant digit of the integer and the last element to the most significant digit. x is clipped to MAX(SET)+1 bits.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BITSHL(x,n)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x, n: INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">logical shift left by n bits, where n &gt;= 0 and â‡ MAX(SET)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BITSHR(x,n)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x, n: INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">logical shift right by n bits, where n &gt;= 0 and n â‡ MAX(SET)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BITXOR(x,y)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x, y: INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bitwise XOR</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CAST(T,x)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T:enumeration type x:ordinal number</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">enumeration type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">the enum item with the ordinal number x; halt if no match</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CHR(x)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x: INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CHAR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Latin-1 character with ordinal number x; x is clipped to 8 bits</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CLIP(x)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x: INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BYTE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">clips x to 8 bits</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DEFAULT(T)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T = basic type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">zero for numeric and character types, false for boolean, empty set</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T = enumeration type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">same as MIN(T)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T = proc type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">nil</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T = structured type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">nil</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">FLOOR(x)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x: REAL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">largest integer not greater than x</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">FLT(x)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x: INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">REAL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Convert integer to real type; accepting potential loss of information</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LEN(v)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">v: array</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">allocated length of the array</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">v: STRING</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">length of STRING (including the terminating 0X)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">KEYS(v)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">v: HASHMAP K OF T</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ARRAY OF K</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">return an array which includes all keys of the dictionary in arbitrary order</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MAX(T)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T = basic type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">maximum value of type T</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T = SET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">maximum element of a set</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T = enumeration type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">last element of the enumeration</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MAX(x,y)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x,y: numeric type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">numeric type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">greater of x and y, returns smallest numeric type including both arguments</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MIN(T)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T = basic type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">minimum value of type T</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T = SET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T = enumeration type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">first element of the enumeration</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MIN(x,y)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x,y: numeric type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">numeric type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">smaller of x and y, returns smallest numeric type including both arguments</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ODD(x)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x: INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BOOLEAN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x MOD 2 = 1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ORD(x)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x: CHAR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ordinal number of x</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x: enumeration type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ordinal number of the given identifier</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x: BOOLEAN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INTE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TRUE = 1, FALSE = 0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x: set type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">number representing the set; the first element corresponds to the least significant digit of the number and the last element to the most significant digit.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">STRLEN(s)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">s: array of char</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">dynamic length of the string up to and not including the terminating 0X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">s: STRING</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">TOSTRING(x)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x: any type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">STRING</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">returns a STRING representation of x</p></td>
</tr>
</tbody>
</table>
<div class="literalblock">
<div class="title">Exampes:</div>
<div class="content">
<pre>FLOOR(1.5) = 1; FLOOR(-1.5) = -2</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_predeclared_proper_procedures">10.4.2. Predeclared proper procedures</h4>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 33.3333%;">
<col style="width: 50.0001%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Argument types</th>
<th class="tableblock halign-left valign-top">Function</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ASSERT(x)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x: Boolean expression</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">terminate program execution if not x</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">COPY(x, y)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x, y: structured types</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">creates a (shallow) copy of the y instance and assigns it to x</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x: ARRAY OF CHAR; y: STRING</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">creates an open CHAR array of length STRLEN(y)+1 and copies all characters including terminating 0x</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DEC(v)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">v := v - 1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">enumeration type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">previous ident in enumeration</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DEC(v, n)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">v, n: integer type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">v := v - n</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">EXCL(v, x)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">v: SET; x: integer type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">v := v - {x}</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HALT(n)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer constant</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">terminate program execution</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">INC(v)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">v := v + 1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">enumeration type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">next ident in enumeration</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">INC(v, n)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">v, n: integer type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">v := v + n</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">INCL(v, x)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">v: SET; x: integer type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">v := v + {x}</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NEW(v)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">record, fixed array, dictionary</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">allocates a new instance initialized with default values and sets v to the reference</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NEW(v, x)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">open array</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">like NEW(v) for a fixed array of length x</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PCALL(e,p,a<sub>0</sub>,â€¦â€‹,a<sub>n</sub>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VAR e: anyrec; p: proper procedure type; a<sub>i</sub>: actual parameters</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">call procedure type p with arguments a<sub>0</sub>â€¦â€‹a<sub>n</sub> corresponding to the parameter list of p; e becomes nil in normal case and gets the record passed to RAISE() otherwise</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PRINT(v)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">v: any type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">prints a representation of v to the terminal</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PRINTLN(v)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">v: any type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">like PRINT, but adds a new line afterwards</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">RAISE(e)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">e: anyrec</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">terminates the last protected function called and returns e as the exception value; RAISE() never returns</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>In <code>HALT(n)</code>, the interpretation of <code>n</code> is left to the underlying system implementation.</p>
</div>
<div class="paragraph">
<p>A compiler can add the TRAP and TRAPIF(cond) procedures to trigger a break in the debugger at the position, with an optional condition</p>
</div>
<div class="paragraph">
<p>The predeclared procedure NEW is used to allocate data blocks in free memory. There is, however, no way to explicitly dispose an allocated block. Rather, the Luon runtime uses a garbage collector to find the blocks that are not used any more and to make them available for allocation again. A block is in use as long as it can be reached from a variable via a reference chain. Cutting this chain (e.g., setting a variable to NIL) makes the block collectable.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_modules">11. Modules</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A module is a collection of declarations of constants, types, variables, and procedures, together with a sequence of statements for the purpose of assigning initial values to the variables. A module constitutes a text that is compilable as a unit (compilation unit).</p>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>module     = MODULE ident [ MetaParams ] [';']
             { ImportList | DeclarationSequence }
	         [ BEGIN StatementSequence ] END ident ['.']
ImportList = IMPORT import { [','] import } [';']
import     = [ ident ':=' ] ImportPath ident [ MetaActuals ]
ImportPath = { ident '.' }</pre>
</div>
</div>
<div class="paragraph">
<p>The import list specifies the names of the imported modules. If a module A is imported by a module M and A exports an identifier <code>x</code>, then <code>x</code> is referred to as <code>A.x</code> within M.</p>
</div>
<div class="paragraph">
<p>If A is imported as <code>B := A</code>, the object <code>x</code> must be referenced as <code>B.x</code>. This allows short alias names in qualified identifiers.</p>
</div>
<div class="paragraph">
<p>In Luon the import can refer to a module by means of a module name optionally prefixed with an import path. There is no requirement that the import path actually exists in the file system, or that the source files corresponding to an import path are in the same file system directory. It is up to the compiler, how source files are mapped to import paths. An imported module with no import path is first looked up in the import path of the importing module.</p>
</div>
<div class="paragraph">
<p>A module must not import itself.</p>
</div>
<div class="paragraph">
<p>Identifiers that are to be exported (i.e. that are to be visible in client modules) must be marked by an export mark in their declaration (see Chapter <a href="#_declarations_and_scope_rules">Declarations and scope rules</a>).</p>
</div>
<div class="paragraph">
<p>The statement sequence following the symbol BEGIN is executed when the module is loaded, which is done after the imported modules have been loaded. It follows that cyclic import of modules is illegal.</p>
</div>
<div id="oberon-2-example" class="listingblock">
<div class="title">Listing 3. Example with more traditional syntax</div>
<div class="content">
<pre class="highlight"><code class="language-oberon" data-lang="oberon">MODULE Lists;
	IMPORT Out;
    TYPE
        List*    = ListNode;
        ListNode = RECORD
            value : INTEGER;
            next  : List;
        END;

    PROCEDURE (l : List) Add* (v : INTEGER);
    BEGIN
        IF l = NIL THEN
            NEW(l);           (* create record instance *)
            l.value := v
        ELSE
            l.next.Add(v)
        END
    END Add;

    PROCEDURE (t: List) Write*;
    BEGIN
    	Out.Int(t.value,8); Out.Ln;
    	IF t.next # NIL THEN t.next.Write END;
    END Write;
END Lists.</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Listing 4. <a href="#oberon-2-example">Same example</a> with syntactic simplifications</div>
<div class="content">
<pre class="highlight"><code class="language-oberon" data-lang="oberon">module Lists2
	import Out
    type
        List*     = record
            value : integer
            next  : List
        end

    proc (l : List) Add* (v : integer)
    begin
        if l = nil then
            new(l)           // create record instance
            l.value := v
        else
            l.next.Add(v)
        end
    end Add

    proc (t: List) Write*
    begin
    	Out.Int(t.value,8); Out.Ln
    	if t.next # nil then t.next.Write end
    end Write
end Lists2</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_generics">11.1. Generics</h3>
<div class="paragraph">
<p>Modules can be made generic by adding formal meta parameters. Meta parameters represent types or constants; the latter include procedures. Meta parameters default to types, but can be explicitly prefixed with the TYPE reserved word; the CONST prefix designates a constant meta parameter. A meta parameter can be constrained with a named type, in which case the actual meta parameter must correspond to this type; the correspondence is established when the generic module is instantiated; the type of the actual meta parameter must be assignment compatible with the constraint type (see <a href="#_definition_of_terms">Definition of terms</a>).</p>
</div>
<div class="paragraph">
<p>Generic modules can be instantiated with different sets of meta actuals which enables the design of reusable algorithms and data structures. The instantiation of a generic module occurs when importing it. A generic module can be instantiated more than once in the same module with different actual meta parameters. See also <a href="#_modules">Modules</a>.</p>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>MetaParams       = '(' MetaSection { [';'] MetaSection } ')'
MetaSection      = [ TYPE | CONST ] ident { [','] ident } [ ':' TypeConstraint ]
TypeConstraint   = NamedType
MetaActuals      = '(' ConstExpression { [','] ConstExpression } ')'
module = MODULE ident [ MetaParams ] [';'] { ImportList | DeclarationSequence }
	[ BEGIN StatementSequence ] END ident ['.']
ImportList = IMPORT import { [','] import } [';']
import = [ ident ':=' ] ImportPath ident [ MetaActuals ]</pre>
</div>
</div>
<div class="paragraph">
<p>Meta parameters can be used within the generic module like normal types or constants. If no type constraint is present, the types and constants can be used wherever no information about the actual type is required; otherwise the type constraint determines the permitted operations. The rules for <em>same types</em> and <em>equal types</em> apply analogously to meta parameters, and subsequently also the corresponding assignment, parameter and array compatibility rules.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
It follows that a type meta parameter can only be the base type of a record, if a record constraint is present(because in absence of the type constraint we donâ€™t know before instantiation whether the type parameter represents e.g. a record or not); but it is e.g. possible to use a record declared in the same or another generic module as a base type.
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>See also <a href="#obx-generics-example">this example</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_source_code_directives">12. Source code directives</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Source code directives are used to set configuration variables in the source text and to select specific pieces of the source text to be compiled (conditional compilation). Luon uses the syntax recommended in <a href="#Oak95">[Oak95]</a>.</p>
</div>
<div class="sect2">
<h3 id="_configuration_variables">12.1. Configuration Variables</h3>
<div class="paragraph">
<p>Configuration variables can be set or unset in the source code using the following syntax:</p>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>directive = '&lt;*' ident ( '+' | '-' ) '*&gt;'</pre>
</div>
</div>
<div class="paragraph">
<p>Each variable is named by an ident which follows the syntax specified in <a href="#_identifiers">Identifiers</a>. Variable names have compilation unit scope which is separate from all other scopes of the program. Configuration variable directives can be placed anywhere in the source code. The directive only affects the present compilation unit, starting from its position in the source code.</p>
</div>
<div class="literalblock">
<div class="title">Example:</div>
<div class="content">
<pre>&lt;* WIN32+ *&gt;
&lt;* WIN64- *&gt;</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Usually the compiler provides the possibility to set configuration variables, e.g. via command line interface.
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_conditional_compilation">12.2. Conditional compilation</h3>
<div class="paragraph">
<p>Conditional compilation directives can be placed anywhere in the source code. The following syntax applies:</p>
</div>
<div class="literalblock">
<div class="title">Syntax:</div>
<div class="content">
<pre>directive = '&lt;*' [ scIf | scElsif | scElse | scEnd ] '*&gt;'
scIf   	  = IF scExpr THEN
scElsif   = ELSIF condition THEN
scElse 	  = ELSE
scEnd 	  = END
condition = scTerm { OR scTerm }
scTerm 	  = scFactor {'&amp;' scFactor}
scFactor  = ident | '(' condition ')' | '~' scFactor</pre>
</div>
</div>
<div class="paragraph">
<p>An ELSIF or ELSE directive must be preceded by an IF or another ELSIF directive. Each IF directive must be ended by an END directive. The directives form sections of the source code. Only the section the condition of which is TRUE (or the section framed by ELSE and END directive otherwise) is visible to the compiler. Conditions are boolean expressions. Ident refers to a configuration variable. When a configuration variable is not explicitly set it is assumed to be FALSE. Each section can contain nested conditional compilation directives.</p>
</div>
<div class="literalblock">
<div class="title">Example:</div>
<div class="content">
<pre>&lt;* if A then *&gt;
  println("A")
&lt;* elsif B &amp; ~C then *&gt;
  println("B &amp; ~C")
&lt;* else *&gt;
  println("D")
&lt;* end *&gt;</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_definition_of_terms">Appendix A: Definition of terms</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1">Integer types</dt>
<dd>
<p>BYTE, INTEGER</p>
</dd>
<dt class="hdlist1">Real types</dt>
<dd>
<p>REAL</p>
</dd>
<dt class="hdlist1">Numeric types</dt>
<dd>
<p>integer types, real types</p>
</dd>
<dt class="hdlist1">Same types</dt>
<dd>
<p>Two variables a and b with types T<sub>a</sub> and T<sub>b</sub> are of the same type if</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>T<sub>a</sub> and T<sub>b</sub> are both denoted by the same type identifier, or</p>
</li>
<li>
<p>T<sub>a</sub> is declared to equal T<sub>b</sub> in a type declaration of the form T<sub>a</sub> = T<sub>b</sub>, or</p>
</li>
<li>
<p>a and b appear in the same identifier list in a variable, record field, or formal parameter declaration.</p>
</li>
</ol>
</div>
</dd>
<dt class="hdlist1">Equal types</dt>
<dd>
<p>Two types T<sub>a</sub> and T<sub>b</sub> are equal if</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>T<sub>a</sub> and T<sub>b</sub> are the <em>same type</em>, or</p>
</li>
<li>
<p>T<sub>a</sub> and T<sub>b</sub> are open array types with <em>equal element types</em>, or</p>
</li>
<li>
<p>T<sub>a</sub> and T<sub>b</sub> are procedure types whose formal parameters <em>match</em>.</p>
</li>
</ol>
</div>
</dd>
<dt class="hdlist1">Type inclusion</dt>
<dd>
<p>Numeric types include (the values of) smaller numeric types. See <a href="#type-inclusion-relations">here</a> for more information.</p>
</dd>
<dt class="hdlist1">Type extension</dt>
<dd>
<p>Given a type declaration T<sub>b</sub> = RECORD(T<sub>a</sub>)â€¦â€‹END, T<sub>b</sub> is a direct extension of T<sub>a</sub>, and T<sub>a</sub> is a direct base type of T<sub>b</sub>. A type T<sub>b</sub> is an extension of a type T<sub>a</sub> (T<sub>a</sub> is a base type of T<sub>b</sub>) if</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>T<sub>a</sub> and T<sub>b</sub> are the <em>same types</em>, or</p>
</li>
<li>
<p>T<sub>b</sub> is a direct extension of T<sub>a</sub>.</p>
</li>
<li>
<p>T<sub>a</sub> is of type ANYREC.</p>
</li>
</ol>
</div>
</dd>
<dt class="hdlist1">Assignment compatible</dt>
<dd>
<p>An expression e of type T<sub>e</sub> is assignment compatible with a variable v of type T<sub>v</sub> if one of the following conditions hold:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>T<sub>e</sub> and T<sub>v</sub> are the <em>same type</em>;</p>
</li>
<li>
<p>T<sub>e</sub> and T<sub>v</sub> are numeric types and T<sub>v</sub> <em>includes</em> T<sub>e</sub>;</p>
</li>
<li>
<p>T<sub>e</sub> and T<sub>v</sub> are record types and T<sub>e</sub> is a <em>type extension</em> of T<sub>v</sub> and the dynamic type of v is T<sub>v</sub>;</p>
</li>
<li>
<p>T<sub>v</sub> is a structured or a procedure type and <code>e</code> is NIL;</p>
</li>
<li>
<p>T<sub>e</sub> is an open array and T<sub>v</sub> is an array of <em>equal</em> base type;</p>
</li>
<li>
<p>T<sub>v</sub> is an array of CHAR, T<sub>e</sub> is a Latin-1 string literal or STRING, and STRLEN(e) &lt; LEN(v);</p>
</li>
<li>
<p>T<sub>v</sub> is a procedure type and <code>e</code> is the name of a procedure whose formal parameters <em>match</em> those of T<sub>v</sub>.</p>
</li>
</ol>
</div>
</dd>
<dt class="hdlist1">Parameter compatible</dt>
<dd>
<p>An actual parameter <code>a</code> of type T<sub>a</sub> is parameter compatible with a formal parameter <code>f</code> of type T<sub>f</sub> if</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>T<sub>f</sub> and T<sub>a</sub> are <em>equal</em> types, or</p>
</li>
<li>
<p><code>f</code> is a value parameter and T<sub>a</sub> is <em>assignment compatible</em> with T<sub>f</sub>, or</p>
</li>
<li>
<p><code>f</code> must be the <em>same type</em> as T<sub>f</sub>, or T<sub>f</sub> must be a record type and T<sub>a</sub> an <em>extension</em> of T<sub>f</sub>.</p>
</li>
</ol>
</div>
</dd>
<dt class="hdlist1">Expression compatible</dt>
<dd>
<p>For a given operator, the types of its operands are expression compatible if they conform to the following table (which shows also the result type of the expression). CHAR arrays that are to be compared must contain 0X as a terminator. Type T1 must be an extension of type T0:</p>
</dd>
</dl>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 12.5%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 37.5%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">operator</th>
<th class="tableblock halign-left valign-top">first operand</th>
<th class="tableblock halign-left valign-top">second operand</th>
<th class="tableblock halign-left valign-top">result type</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">+ - *</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">numeric</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">numeric</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">smallest numeric type including both operands</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">numeric</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">numeric</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">smallest real type type including both operands</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">+ - * /</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SET</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DIV MOD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">smallest integer type type including both operands</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">OR AND &amp; NOT ~</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BOOLEAN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BOOLEAN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BOOLEAN</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">= # &lt;  &lt;= &gt; &gt;=</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">numeric</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">numeric</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BOOLEAN</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CHAR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CHAR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BOOLEAN</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CHAR array, string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CHAR array, string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BOOLEAN</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">= #</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BOOLEAN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BOOLEAN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BOOLEAN</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BOOLEAN</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NIL, structured type T0 or T1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NIL, structured type T0 or T1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BOOLEAN</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure type T, NIL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure type T, NIL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BOOLEAN</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">IN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BOOLEAN</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">IS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">type T0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">type T1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BOOLEAN</p></td>
</tr>
</tbody>
</table>
<div class="dlist">
<dl>
<dt class="hdlist1">Matching formal parameter lists</dt>
<dd>
<p>Two formal parameter lists match if</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>they have the same number of parameters, and</p>
</li>
<li>
<p>parameters at corresponding positions have <em>equal types</em>, and</p>
</li>
<li>
<p>parameters at corresponding positions are both either value, VAR or CONST parameters.</p>
</li>
</ol>
</div>
</dd>
<dt class="hdlist1">Matching result types</dt>
<dd>
<p>The result types of two procedures match if they are either the <em>same type</em> or none.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_syntax_of_luon">Appendix B: Syntax of Luon</h2>
<div class="sectionbody">
<div class="literalblock">
<div class="content">
<pre>qualident = [ ident '.' ] ident
identdef = ident [ '*' | '-' ]
ConstDeclaration = identdef  '=' ConstExpression
ConstExpression = expression
TypeDeclaration = identdef 	'=' type
type = NamedType | ArrayType | DictType | RecordType | ProcedureType | enumeration
NamedType = qualident
ArrayType = ARRAY [ length ] 'OF' type | '[' [ length ] ']' type
length = ConstExpression
DictType = HASHMAP NamedType OF type
RecordType = RECORD ['(' BaseType ')'] { FieldList [ ';' ] } END
BaseType = NamedType
FieldList = IdentList ':' type
IdentList = identdef { [','] identdef}
enumeration = '(' constEnum ')'
constEnum = ident [ '=' ConstExpression ] { [','] ident }
VariableDeclaration = IdentList ':' type
designator = qualident {selector}
selector = '.' ident ['^'] | '[' expression ']' | '(' [ ExpList ] ')'
ExpList = expression { [','] expression }
expression = SimpleExpression [ relation SimpleExpression ]
relation = '=' | '#' | '&lt;' | '&lt;=' | '&gt;' | '&gt;=' | IN | IS
SimpleExpression = ['+' | '-'] term { AddOperator term }
AddOperator = '+' | '-' | OR
term = factor {MulOperator factor}
MulOperator = '*' | '/' | DIV | MOD | '&amp;' | AND
literal = number | string | hexstring | hexchar | NIL | TRUE | FALSE
constructor = [NamedType] '{' [ component {[','] component} ] '}'
component =  ident ':' expression
        | '[' expression ']' ':' expression
        | expression ['..' expression]
factor = constructor
        | literal
		| designator [ActualParameters]
		| '(' expression ')'
		| ('~'| NOT) factor
statement =  designator [ActualParameters]
		| designator  [ ':=' expression ]
		| IfStatement | CaseStatement | LoopStatement
		| ExitStatement | ReturnStatement
		| WhileStatement | RepeatStatement | ForStatement
StatementSequence =  { statement { ';' } }
IfStatement = IF expression THEN StatementSequence { ElsifStatement } [ ElseStatement ] END
ElsifStatement = ELSIF expression THEN StatementSequence
ElseStatement = ELSE StatementSequence
CaseStatement = CASE expression OF [Case] { '|' Case } [ELSE StatementSequence] END
Case = CaseLabelList ':' StatementSequence
CaseLabelList = LabelRange { [','] LabelRange }
LabelRange = label [ '..' label ]
label = ConstExpression
WhileStatement = WHILE expression DO StatementSequence END
RepeatStatement = REPEAT StatementSequence UNTIL expression
ForStatement = FOR ident ':=' expression TO expression [BY ConstExpression] DO StatementSequence END
LoopStatement = LOOP StatementSequence END
ExitStatement = EXIT
procedure = PROCEDURE | PROC
ProcedureType = procedure ['^'] [FormalParameters]
ProcedureDeclaration =  ProcedureHeading (
             	[ ';' ] EXTERN
            	| [INLINE] [ ';' ] ( ProcedureBody | END ) )
ProcedureHeading = procedure [Receiver] identdef [ FormalParameters ]
Receiver = '(' ident ':' ident ')'
block = BEGIN StatementSequence
ProcedureBody = DeclarationSequence block END ident
DeclarationSequence =
			{ CONST { ConstDeclaration [';'] }
			| TYPE { TypeDeclaration [';'] }
			| VAR { VariableDeclaration [';'] }
			| ProcedureDeclaration [';'] }
ReturnStatement = RETURN [ expression ]
FormalParameters = '(' [ FPSection { [';'] FPSection } ] ')' [ ':' ReturnType ]
ReturnType = NamedType
FPSection = [VAR|CONST] ident { [','] ident } ':' FormalType
FormalType = type
module = MODULE ident [ MetaParams ] [';'] { ImportList | DeclarationSequence } [ block ] 'END' ident ['.']
ImportList = IMPORT import { [ ',' ] import } [';']
import = [ ident ':=' ] ident  { '.' ident }  [ MetaActuals ]
MetaActuals = '(' ConstExpression { [','] ConstExpression } ')'
MetaParams = '(' MetaSection { [';'] MetaSection } ')'
MetaSection = [ TYPE | CONST ] ident { \LL:2\ [','] ident } [ ':' NamedType ]</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_more_code_examples">Appendix C: More Code Examples</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="title">Listing 5. Procedural programming</div>
<div class="content">
<pre class="highlight"><code class="language-oberon" data-lang="oberon">module Fibonacci
  proc calc*(n : integer): integer
    var a, b: integer // comma is optional
  begin
    if n &gt; 1 then
      a := calc(n - 1)
      b := calc(n - 2)
      return a + b
    elsif n = 0 then
      return 0
    else
      return 1
    end
  end calc
  var res: integer
begin
  res := calc(21)
  assert(res = 10946)
end Fibonacci</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Listing 6. Generic programming</div>
<div class="content">
<pre class="highlight"><code class="language-oberon" data-lang="oberon">module Collections(T)
  type Deque* = record
                      data: array of T
                      size: integer end
  proc createDeque*(): Deque
    const initial_len = 50
    var this: Deque  // this is initialized to nil
  begin
    new(this); new(this.data,initial_len)
             // semicolon is optional
    return this
    // this and data will be garbage collected
  end createDeque

  proc (this: Deque) append*(const element: T)
  begin
    if this.size = len(this.data) then assert(false) end
    this.data[this.size] := element inc(this.size)
  end append

  type Iterator* = record end
  proc (this: Iterator) apply*(const element: T) end

  proc (this: Deque) forEach*(var iter: Iterator)
    var i: integer
  begin
    for i := 0 to this.size-1 do
      iter.apply(this.data[i])
    end
  end forEach
end Collections</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Listing 7. Object-oriented programming</div>
<div class="content">
<pre class="highlight"><code class="language-oberon" data-lang="oberon">module Drawing
  import F := Fibonacci
         C := Collections(Figure)

  type Figure* = record
                   position: record
                     x,y: integer end end
  proc (this: Figure) draw*() end

  type
     Circle* = record (Figure)
                          diameter: integer end
     Square* = record (Figure)
                          width: integer end
  proc (this: Circle) draw*() end
  proc (this: Square) draw*() end

  var figures: C.Deque
       circle: Circle
       square: Square

  proc drawAll()
    type I = record(C.Iterator) count: integer end
    proc (this: I) apply( in figure: Figure )
    begin
      figure.draw(); inc(this.count)
    end apply
    var i: I // count is initialized to zero
  begin
  	new(i)
    figures.forEach(i)
    assert(i.count = 2)
  end drawAll
begin
  figures := C.createDeque()
  new(circle); new(circle.position)
  circle.position.x := F.calc(3)
  circle.position.y := F.calc(4)
  circle.diameter := 3
  figures.append(circle)
  new(square); new(square.position)
  square.position.x := F.calc(5)
  square.position.y := F.calc(6)
  square.width := 4
  figures.append(square)
  drawAll()
end Drawing</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_references">Appendix D: References</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a id="Ada83"></a>[Ada83] ISO 8652:1987 Programming languages â€” Ada. International Organization for Standardization.</p>
</li>
<li>
<p><a id="Mo91"></a>[Mo91] MÃ¶ssenbÃ¶ck, H.; Wirth, N. (1991). The Programming Language Oberon-2. Structured Programming, 12(4):179-195, 1991. <a href="http://www.ssw.uni-linz.ac.at/Research/Papers/Oberon2.pdf" class="bare">http://www.ssw.uni-linz.ac.at/Research/Papers/Oberon2.pdf</a> (accessed 2020-11-16).</p>
</li>
<li>
<p><a id="Oak95"></a>[Oak95] Kirk, B. et al. (1995). The Oakwood Guidelines for Oberon-2 Compiler Developers. Revision 1A. <a href="https://web.archive.org/web/20171226172235/https://www.math.bas.bg/bantchev/place/oberon/oakwood-guidelines.pdf" class="bare">https://web.archive.org/web/20171226172235/https://www.math.bas.bg/bantchev/place/oberon/oakwood-guidelines.pdf</a> (accessed 2022-04-26).</p>
</li>
<li>
<p><a id="Wi16"></a>[Wi16] Wirth, N. (2016). The Programming Language Oberon. <a href="https://people.inf.ethz.ch/wirth/Oberon/Oberon07.Report.pdf" class="bare">https://people.inf.ethz.ch/wirth/Oberon/Oberon07.Report.pdf</a> (accessed 2020-11-16).</p>
</li>
<li>
<p><a id="Wi73"></a>[Wi73] Wirth, N. (1973). The Programming Language Pascal (Revised Report). ETH Report. <a href="https://doi.org/10.3929/ethz-a-000814158" class="bare">https://doi.org/10.3929/ethz-a-000814158</a> (accessed 2020-11-16).</p>
</li>
<li>
<p><a id="Wi87"></a>[Wi87] Wirth, N. (1987). From Modula to Oberon and the programming language Oberon. ETH Report. <a href="https://doi.org/10.3929/ethz-a-005363226" class="bare">https://doi.org/10.3929/ethz-a-005363226</a> (accessed 2020-11-16).</p>
</li>
<li>
<p><a id="Lua05"></a> Ierusalimschy, R., De Figueiredo, L. H., &amp; Celes Filho, W. (2005). The Implementation of Lua 5.0. J. Univers. Comput. Sci., 11(7), 1159-1176.</p>
</li>
</ul>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnote_1">
<a href="#_footnoteref_1">1</a>. generic modules, inspired by <a href="#Ada83">[Ada83]</a>
</div>
</div></div><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>	function init_doc_0124_2(){		if(typeof MathJax !== "undefined"){ MathJax.Hub.Queue(["Typeset",MathJax.Hub]); }};</script></body></html>
